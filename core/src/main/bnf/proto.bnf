// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

{
  generate=[names="long" psi="yes" tokens="no"]

  parserClass="idea.plugin.protoeditor.lang.parser.PbParser"
  parserUtilClass="idea.plugin.protoeditor.lang.parser.PbParserUtil"
  parserImports=[
    "com.intellij.lang.parser.GeneratedParserUtilBase.Parser"
    "static idea.plugin.protoeditor.lang.psi.ProtoTokenTypes.*"
  ]

  implements="idea.plugin.protoeditor.lang.psi.PbElement"
  extends="idea.plugin.protoeditor.lang.psi.impl.PbElementBase"

  psiClassPrefix="Pb"
  psiImplClassSuffix="Impl"
  psiPackage="idea.plugin.protoeditor.lang.psi"
  psiImplPackage="idea.plugin.protoeditor.lang.psi.impl"
  psiImplUtilClass="idea.plugin.protoeditor.lang.psi.util.PbPsiImplUtil"
  psiTreeUtilClass="idea.plugin.protoeditor.lang.psi.util.PbPsiTreeUtil"

  elementTypeHolderClass="idea.plugin.protoeditor.lang.psi.PbTypes"
  elementTypeClass="idea.plugin.protoeditor.lang.psi.PbElementType"

  // Allow parsing from any rule, maintaining compatibility with older GK versions.
  extraRoot("*")=true

  tokens=[

    // The tokens listed below are defined in ProtoTokenTypes.java, and generated by the lexer in proto.flex.
    // They're listed below for a couple of reasons:
    //
    // 1. They instruct a Grammar-Kit parser to match by token rather than by string. So, for
    //    example, a rule containing '(' will look for the LPAREN token rather than the "(" string
    //    since the token and text are listed below.
    // 2. They power Grammar-Kit's "live preview" feature. The regexp tokens are only useful in
    //    live preview; the actual lexer expressions are found in proto.flex.
    //
    // Additionally, unquoted strings in the grammar that do not match rule names become additional
    // token types. For example, "message" and "group".

    // This token is only useful when using the Grammar-Kit plugin's "Live Preview" feature.
    TESTING_WHITESPACE = "regexp:[ \n\t\r\f]+"

    // Comments
    LINE_COMMENT = "regexp://[^\n]*\n?"
    BLOCK_COMMENT = "regexp:(/\*([^*]|(\*+[^*/]))*(\*+/))"

    // Identifiers
    IDENTIFIER_LITERAL = "regexp:[a-zA-Z_][a-zA-Z0-9_]*"

    // Numbers
    INTEGER_LITERAL = "regexp:(0|[1-9][0-9]*)|(0[xX][0-9a-fA-F]+)|(0[0-7]+)"
    FLOAT_LITERAL = "regexp:(\.[0-9]+|(0|[1-9][0-9]*)\.[0-9]*|(0|[1-9][0-9]*))([eE][-+]?[0-9]+)?[fF]?"

    // String literals
    STRING_LITERAL = "regexp:(\'(\\.|[^\'\n])*\')|(\"(\\.|[^\"\n])*\")"

    // Symbols
    ASSIGN = '='
    COMMA = ','
    DOT = '.'
    GT = '>'
    LBRACE = '{'
    LBRACK = '['
    LPAREN = '('
    LT = '<'
    MINUS = '-'
    RBRACE = '}'
    RBRACK = ']'
    RPAREN = ')'
    SEMI = ';'

    // A catch-all for other types of symbols that might appear.
    SYMBOL = "regexp:[!#$%&()*+,-./:;<=>?@\[\\\]\^`{|}~]"
  ]
}

/*
 * The root of the proto file.
 */
Root ::= SyntaxStatement? RootEntry*
private RootEntry ::= !<<eof>> TopLevelEntry { pin = 1 }

/*
 * Identifiers. Any string that matches {Alpha}{Alphanumeric}*.
 *
 * protoc's lexer does not differentiate between language keywords (such as "message" and "group")
 * and user-provided names. All are considered IDENTIFIER tokens, and as such keywords can be used
 * as object names (e.g., "message message { ... }" is valid).
 *
 * This rule uses the external parseKeywordIdentifier method to allow it to also match keywords
 * (such as message, group, etc.), which would otherwise only be matched by their corresponding
 * keyword tokens.
 */
private Identifier ::= IDENTIFIER_LITERAL | <<parseKeywordIdentifier>>

/*
 * A SymbolPath is a recursive structure comprised of dot-separated identifiers representing
 * a qualified type name. For example, net.proto2.FileOptions. Each SymbolPath element has an
 * optional SymbolPath parent (a qualifier) and a symbol identifier.
 *
 * By default, left recursive rules are not supported by Grammar Kit (they generate endless
 * recursion in the parser). But the structure of the rules below causes Grammar Kit to generate
 * a special expression-parsing parser. Specifically, a top-level rule (SymbolPath) that consists of
 * a choice between sub-rules that all extend the top-level rule.
 */
SymbolPath ::= SymbolPathTuple | SymbolPathUnit
{
  implements = 'idea.plugin.protoeditor.lang.psi.ProtoSymbolPath'
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbSymbolPathMixin'
}
SymbolPathTuple ::= SymbolPath '.' SymbolPathAtom { elementType = SymbolPath }
SymbolPathUnit ::= SymbolPathAtom { elementType = SymbolPath }
private SymbolPathAtom ::= Identifier

/*
 * A qualified reference. A series of identifiers separated by dots, with an optional leading dot
 * indicating that the reference is fully qualified. TypeNames and ExtensionNames both
 * use this form.
 */
private QualifiedName ::= '.'? SymbolPath

TypeName ::= QualifiedName
{
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbTypeNameBase'
    'idea.plugin.protoeditor.lang.psi.PbQualifiedReference'
    'idea.plugin.protoeditor.lang.psi.EffectiveReferenceOwner'
    'idea.plugin.protoeditor.lang.psi.ProtoSymbolPathContainer'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbTypeNameMixin'
}

/* A TypeName that must be a message type. */
MessageTypeName ::= QualifiedName { extends = TypeName }

ExtensionName ::= QualifiedName
{
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbQualifiedReference'
    'idea.plugin.protoeditor.lang.psi.EffectiveReferenceOwner'
    'idea.plugin.protoeditor.lang.psi.ProtoSymbolPathContainer'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbExtensionNameMixin'
}

/*
 * A package name. A series of identifiers separated by dots, without a leading dot.
 * This is identical to a SymbolPath in structure, but the PSI implementation is different.
 */
PackageName ::= PackageNameTuple | PackageNameUnit
{
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbPackageNameBase'
    'idea.plugin.protoeditor.lang.psi.PbSymbol'
    'idea.plugin.protoeditor.lang.psi.PbSymbolOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbPackageNameMixin'
}
PackageNameTuple ::= PackageName '.' PackageNameAtom { elementType = PackageName }
PackageNameUnit ::= PackageNameAtom { elementType = PackageName }
private PackageNameAtom ::= Identifier

/*
 * A complex dot-separated combination of parenthesized ExtensionName and Identifier tokens.
 */
OptionName ::= OptionNameTuple | OptionNameUnit
{
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbOptionNameBase'
    'idea.plugin.protoeditor.lang.psi.EffectiveReferenceOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbOptionNameMixin'
}
OptionNameTuple ::= OptionName '.' OptionNameAtom { elementType = OptionName }
OptionNameUnit ::= OptionNameAtom { elementType = OptionName }
private OptionNameAtom ::= OptionExtensionName | Identifier
private OptionExtensionName ::= '(' ExtensionName ')' { pin = 2 }


/*
 * String literals.
 * Multiple adjacent quoted strings are treated as a single string.
 */
StringValue ::= StringPart+
{
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbLiteral'
    'idea.plugin.protoeditor.lang.psi.PbElement'
    'idea.plugin.protoeditor.lang.psi.ProtoStringValue'
  ]
  methods = [
    stringParts = 'StringPart'
  ]
}
StringPart ::= STRING_LITERAL
{
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbElement'
    'idea.plugin.protoeditor.lang.psi.ProtoStringPart'
  ]
}

/*
 * Numbers.
 */
NumberValue ::= '-'? (INTEGER_LITERAL | FLOAT_LITERAL | "inf" | "nan")
{
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbLiteral'
    'idea.plugin.protoeditor.lang.psi.PbElement'
    'idea.plugin.protoeditor.lang.psi.ProtoNumberValue'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbNumberValueMixin'
}
IntegerValue ::= '-'? INTEGER_LITERAL { elementType = NumberValue }

/*
 * An identifier used as a value. Can be a boolean or an enum value depending on context.
 */
IdentifierValue ::= Identifier {
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbLiteral'
    'idea.plugin.protoeditor.lang.psi.ProtoIdentifierValue'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbIdentifierValueMixin'
}

// An aggregate value used to initialize message field options. Aggregate values are expressed using
// the proto text format: an AggregateValue is itself a PbTextMessage.
AggregateValue ::= <<Block <<BlockBodyOptional AggregateValueEntry>>>> {
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbLiteral'
    'idea.plugin.protoeditor.lang.psi.PbBlockBody'
    'idea.plugin.protoeditor.lang.psi.PbTextRootMessage'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbAggregateValueMixin'
  methods = [
    start = 'LBRACE'
    end = 'RBRACE'
  ]
}
private AggregateValueEntry ::= <<parseTextField>> {
  recoverWhile = AggregateValueRecovery
}
private AggregateValueRecovery ::= !('}' | <<parseTextFieldName>>)

/*
 * A list of rules separated by comma tokens. Parameters to this meta rule are the list terminator
 * (e.g., ';' or ']'), and the list entry rule.
 */
private meta CommaSeparatedList ::= !<<term>> <<entry>> (!<<term>> ',' <<entry>>)* { pin(".*") = 1 }

/*
 * A block of rules surrounded by braces.
 */
private meta Block ::= '{' <<p>> '}' { pin = 1 }
private meta BlockBodyOptional ::= <<BlockEntry <<p>> >>*
private meta BlockEntry ::= !'}' <<p>> { pin = 1 }

/*
 * Syntax statement.
 */
SyntaxStatement ::= syntax '=' StringValue ';'
{
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbSyntaxStatementBase'
    'idea.plugin.protoeditor.lang.psi.PbStatement'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbSyntaxStatementMixin'
}

/*
 * Top level entries.
 */
private TopLevelEntry ::=
    MessageDefinition
  | EnumDefinition
  | ServiceDefinition
  | ExtendDefinition
  | ImportStatement
  | PackageStatement
  | OptionStatement
  | ';'
  { recoverWhile = TopLevelRecovery }

private TopLevelRecovery ::= !(message | enum | service | extend | import | package | option | ';')

/*
 * Package statement.
 */
PackageStatement ::= package PackageName ';'
{
  pin = 1
  implements = 'idea.plugin.protoeditor.lang.psi.PbStatement'
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbPackageStatementMixin'
  stubClass = 'idea.plugin.protoeditor.lang.stub.PbPackageStatementStub'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.stub.type.PbStubElementTypes.get'
}

/*
 * Import statement.
 */
ImportStatement ::= import (public | weak)? ImportName ';' {
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbImportStatementBase'
    'idea.plugin.protoeditor.lang.psi.PbStatement'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbImportStatementMixin'
}
ImportName ::= StringValue
{
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbImportNameMixin'
}

/*
 * Message definition.
 */
MessageDefinition ::= message Identifier MessageBody {
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbDefinition'
    'idea.plugin.protoeditor.lang.psi.PbMessageType'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbMessageDefinitionMixin'
  stubClass = 'idea.plugin.protoeditor.lang.stub.PbMessageDefinitionStub'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.stub.type.PbStubElementTypes.get'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
    body = 'MessageBody'
  ]
}
MessageBody ::= <<Block <<BlockBodyOptional MessageEntry>> >> {
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbBlockBody'
    'idea.plugin.protoeditor.lang.psi.PbOptionStatementOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbMessageBodyMixin'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.psi.type.PbCustomTypes.get'
  methods = [
    optionStatements = 'OptionStatement'
    start = 'LBRACE'
    end = 'RBRACE'
  ]
}
private MessageEntry ::=
    MessageDefinition
  | EnumDefinition
  | ExtensionsStatement
  | ReservedStatement
  | ExtendDefinition
  | OptionStatement
  | OneofDefinition
  | MapField
  | GroupDefinition
  | SimpleField
  | ';' { recoverWhile = MessageRecovery }

private MessageRecovery ::=
  !(message | enum | extensions | reserved | extend | option | oneof
  | FieldLabel | group | map | TypeName | '}' | ';')

/*
 * Option statement and body
 */
OptionExpression ::= OptionName '=' (IdentifierValue | NumberValue | StringValue | AggregateValue) {
  pin = 1
  implements = "idea.plugin.protoeditor.lang.psi.PbOptionExpressionBase"
}
OptionStatement ::= option OptionExpression ';' {
  pin = 1
  implements = 'idea.plugin.protoeditor.lang.psi.PbStatement'
}
/*
 * Field options.
 */
OptionList ::= '[' <<CommaSeparatedList ']' OptionListEntry>> ']' {
  implements = 'idea.plugin.protoeditor.lang.psi.PbBlockBody'
  methods = [
    options = 'OptionExpression'
    start = 'LBRACK'
    end = 'RBRACK'
  ]
  pin = 1
}
private OptionListEntry ::= OptionExpression { recoverWhile = OptionListEntryRecovery }
private OptionListEntryRecovery ::= !(OptionName | ',' | ']') MessageRecovery

/*
 * Field labels. Only Groups and simple fields can be labeled in certain contexts.
 */
FieldLabel ::= optional | required | repeated

/*
 * Simple fields.
 *
 * Since TypeName ultimately generalizes to Identifier, which can match any
 * {Alpha}{Alphanumeric}* string, SimpleField should come at the end of rule option sequences.
 * E.g., "group abcd = 5 {}" will be matched by `TypeName Identifier '='` unless the
 * GroupDefinition rule is allowed to match it first.
 */
SimpleField ::= FieldLabel? TypeName Identifier '=' IntegerValue OptionList? ';' {
  pin = 2
  implements = 'idea.plugin.protoeditor.lang.psi.PbField'
  extends = 'idea.plugin.protoeditor.lang.psi.impl.PbFieldBase'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
    fieldNumber = 'NumberValue'
    declaredLabel = 'FieldLabel'
  ]
}

/*
 * Map fields.
 * Note that map fields do not allow field labels, but we allow the syntax to generate a
 * user-friendly annotation.
 */
MapField ::= FieldLabel? map '<' TypeName ',' TypeName '>' Identifier '=' IntegerValue OptionList? ';' {
  pin = 3 // We pin the '<' to allow SimpleFields to use 'map' as a type name.
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbField'
    'idea.plugin.protoeditor.lang.psi.PbSymbolContributor'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbMapFieldMixin'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
    fieldNumber = 'NumberValue'
    keyType = 'TypeName[0]'
    valueType = 'TypeName[1]'
    TypeName = ''
    declaredLabel = 'FieldLabel'
  ]
}

/*
 * Group field. Groups act like both fields and message definitions.
 */
GroupDefinition ::= FieldLabel? group Identifier '=' IntegerValue GroupOptionContainer? MessageBody {
  pin = 2
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbDefinition'
    'idea.plugin.protoeditor.lang.psi.PbMessageType'
    'idea.plugin.protoeditor.lang.psi.PbSymbolContributor'
    'idea.plugin.protoeditor.lang.psi.PbGroupDefinitionBase'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbGroupDefinitionMixin'
  stubClass = 'idea.plugin.protoeditor.lang.stub.PbGroupDefinitionStub'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.stub.type.PbStubElementTypes.get'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
    body = 'MessageBody'
    fieldNumber = 'NumberValue'
    declaredLabel = 'FieldLabel'
  ]
}
GroupOptionContainer ::= OptionList {
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbGroupOptionContainerMixin'
  methods = [
    options = 'OptionList/OptionExpression'
  ]
}

/*
 * OneOf definition.
 */
OneofDefinition ::= oneof Identifier OneofBody {
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbDefinition'
    'idea.plugin.protoeditor.lang.psi.PbNamedElement'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbOneofDefinitionMixin'
  stubClass = 'idea.plugin.protoeditor.lang.stub.PbOneofDefinitionStub'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.stub.type.PbStubElementTypes.get'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
    body = 'OneofBody'
  ]
}
OneofBody ::= <<Block <<BlockBodyOptional OneofEntry>> >> {
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbBlockBody'
    'idea.plugin.protoeditor.lang.psi.PbOptionStatementOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbOneofBodyMixin'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.psi.type.PbCustomTypes.get'
  methods = [
    optionStatements = 'OptionStatement'
    start = 'LBRACE'
    end = 'RBRACE'
  ]
}
private OneofEntry ::= (OptionStatement | GroupDefinition | SimpleField) { recoverWhile = OneofRecovery }
private OneofRecovery ::= !(FieldLabel | option | group | TypeName | ';' | '}')

/*
 * Extend definition.
 */
ExtendDefinition ::= extend MessageTypeName ExtendBody {
  pin = 1
  implements = 'idea.plugin.protoeditor.lang.psi.PbDefinition'
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbExtendDefinitionMixin'
  stubClass = 'idea.plugin.protoeditor.lang.stub.PbExtendDefinitionStub'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.stub.type.PbStubElementTypes.get'
  methods = [
    body = 'ExtendBody'
    typeName = 'MessageTypeName'
  ]
}
ExtendBody ::= <<Block <<BlockBodyOptional ExtendEntry>> >> {
  implements = 'idea.plugin.protoeditor.lang.psi.PbBlockBody'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.psi.type.PbCustomTypes.get'
  methods = [
    start = 'LBRACE'
    end = 'RBRACE'
  ]
}
private ExtendEntry ::= GroupDefinition | SimpleField { recoverWhile = ExtendRecovery }
private ExtendRecovery ::= !(FieldLabel | group | TypeName | ';' | '}')

/*
 * Extensions statement.
 */
ExtensionsStatement ::= extensions <<CommaSeparatedList ('[' | ';') ExtensionRange>> OptionList? ';' {
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbStatement'
    'idea.plugin.protoeditor.lang.psi.PbOptionOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbExtensionsStatementMixin'
}
ExtensionRange ::= IntegerValue (to (IntegerValue | max))?
{
  pin(".*") = 1
  recoverWhile = ExtensionRangeRecovery
  implements = 'idea.plugin.protoeditor.lang.psi.PbExtensionRangeBase'
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbExtensionRangeMixin'
  methods = [
    fromValue = 'NumberValue[0]'
    toValue = 'NumberValue[1]'
  ]
}
private ExtensionRangeRecovery ::= !(IntegerValue | ',' | '[' | ';') MessageRecovery

/*
 * Reserved statement.
 */
ReservedStatement ::= reserved (ReservedNames | ReservedNumbers) ';'
{
  pin = 1
  implements = 'idea.plugin.protoeditor.lang.psi.PbStatement'
  extends = 'idea.plugin.protoeditor.lang.psi.impl.PbStatementBase'
}
ReservedRange ::= IntegerValue (to (IntegerValue | max))?
{
  pin(".*") = 1
  recoverWhile = ReservedRangeRecovery
  implements = 'idea.plugin.protoeditor.lang.psi.PbReservedRangeBase'
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbReservedRangeMixin'
  methods = [
    fromValue = 'NumberValue[0]'
    toValue = 'NumberValue[1]'
  ]
}
private ReservedRangeRecovery ::= !(IntegerValue | ',') MessageRecovery

// These rules start with lookahead predicates (&...) for disambiguation.
private ReservedNames ::= &StringValue <<CommaSeparatedList ';' StringValue>>
private ReservedNumbers ::= &IntegerValue <<CommaSeparatedList ';' ReservedRange>>

/*
 * Enum definition.
 */
EnumDefinition ::= enum Identifier EnumBody
{
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbDefinition'
    'idea.plugin.protoeditor.lang.psi.PbNamedTypeElement'
    'idea.plugin.protoeditor.lang.psi.PbEnumDefinitionBase'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbEnumDefinitionMixin'
  stubClass = 'idea.plugin.protoeditor.lang.stub.PbEnumDefinitionStub'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.stub.type.PbStubElementTypes.get'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
    body = 'EnumBody'
  ]
}
EnumValue ::= Identifier '=' IntegerValue OptionList? ';'
{
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbNamedElement'
    'idea.plugin.protoeditor.lang.psi.PbOptionOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbEnumValueMixin'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
  ]
}
EnumBody ::= <<Block <<BlockBodyOptional EnumEntry>> >> {
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbBlockBody'
    'idea.plugin.protoeditor.lang.psi.PbOptionStatementOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbEnumBodyMixin'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.psi.type.PbCustomTypes.get'
  methods = [
    optionStatements = 'OptionStatement'
    start = 'LBRACE'
    end = 'RBRACE'
  ]
}
private EnumEntry ::= OptionStatement | EnumReservedStatement | EnumValue | ';' { recoverWhile = EnumRecovery }
private EnumRecovery ::= !(option | reserved | EnumValue | ';' | '}')

/*
 * Reserved statement for enums.
 */
EnumReservedStatement ::= reserved (EnumReservedNames | EnumReservedNumbers) ';'
{
  pin = 1
  implements = 'idea.plugin.protoeditor.lang.psi.PbStatement'
  extends = 'idea.plugin.protoeditor.lang.psi.impl.PbStatementBase'
}
EnumReservedRange ::= IntegerValue (to (IntegerValue | max))?
{
  pin(".*") = 1
  recoverWhile = EnumReservedRangeRecovery
  implements = 'idea.plugin.protoeditor.lang.psi.PbReservedRangeBase'
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbEnumReservedRangeMixin'
  methods = [
    fromValue = 'NumberValue[0]'
    toValue = 'NumberValue[1]'
  ]
}
private EnumReservedRangeRecovery ::= !(IntegerValue | ',') EnumRecovery

// These rules start with lookahead predicates (&...) for disambiguation.
private EnumReservedNames ::= &StringValue <<CommaSeparatedList ';' StringValue>>
private EnumReservedNumbers ::= &IntegerValue <<CommaSeparatedList ';' EnumReservedRange>>

/*
 * Service definition.
 */
ServiceDefinition ::= service Identifier ServiceBody {
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbDefinition'
    'idea.plugin.protoeditor.lang.psi.PbNamedElement'
    'idea.plugin.protoeditor.lang.psi.PbSymbolOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbServiceDefinitionMixin'
  stubClass = 'idea.plugin.protoeditor.lang.stub.PbServiceDefinitionStub'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.stub.type.PbStubElementTypes.get'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
    body = 'ServiceBody'
  ]
}
ServiceBody ::= <<Block <<BlockBodyOptional ServiceEntry>> >> {
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbBlockBody'
    'idea.plugin.protoeditor.lang.psi.PbOptionStatementOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbServiceBodyMixin'
  elementTypeFactory = 'idea.plugin.protoeditor.lang.psi.type.PbCustomTypes.get'
  methods = [
    optionStatements = 'OptionStatement'
    start = 'LBRACE'
    end = 'RBRACE'
  ]
}
private ServiceEntry ::= OptionStatement | ServiceStream | ServiceMethod | ';' { recoverWhile = ServiceRecovery }
private ServiceRecovery ::= !(option | stream | rpc | ';' | '}')

/*
 * Service stream. (Not available in open source release.)
 */
ServiceStream ::= stream Identifier '(' MessageTypeName ',' MessageTypeName ')' (MethodOptions | ';')
{
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbNamedElement'
    'idea.plugin.protoeditor.lang.psi.PbOptionStatementOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbServiceStreamMixin'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
  ]
}
/*
 * Service method (rpc).
 */
ServiceMethod ::= rpc Identifier '(' ServiceMethodType ')' returns '(' ServiceMethodType ')' (MethodOptions | ';')
{
  pin = 1
  implements = [
    'idea.plugin.protoeditor.lang.psi.PbNamedElement'
    'idea.plugin.protoeditor.lang.psi.PbOptionStatementOwner'
  ]
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbServiceMethodMixin'
  methods = [
    nameIdentifier = 'IDENTIFIER_LITERAL'
  ]
}
ServiceMethodType ::= stream? MessageTypeName
{
  implements = 'idea.plugin.protoeditor.lang.psi.PbServiceMethodTypeBase'
  mixin = 'idea.plugin.protoeditor.lang.psi.impl.PbServiceMethodTypeMixin'
}
MethodOptions ::= <<Block <<BlockBodyOptional MethodOptionsEntry>> >> {
  implements = 'idea.plugin.protoeditor.lang.psi.PbBlockBody'
  methods = [
    optionStatements = 'OptionStatement'
    start = 'LBRACE'
    end = 'RBRACE'
  ]
}
private MethodOptionsEntry ::= (OptionStatement | ';') { recoverWhile = MethodOptionsRecovery }
private MethodOptionsRecovery ::= !(option | ';' | '}')
